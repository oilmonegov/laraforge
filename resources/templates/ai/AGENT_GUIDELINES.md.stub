# AI Agent Guidelines for {{ projectName }}

Generated by LaraForge - Last Updated: {{ updatedAt }}

---

## Core Principles

### 1. Code Quality First
- **Strict Types**: All PHP files MUST use `declare(strict_types=1);`
- **Type Declarations**: All method parameters and return types MUST be declared
- **No Magic**: Avoid magic methods, dynamic properties, and implicit behavior
- **Explicit Over Implicit**: Always be explicit in code intentions

### 2. Security by Default
- **Input Validation**: Validate ALL user inputs at system boundaries
- **Output Encoding**: Always encode output to prevent XSS
- **SQL Injection**: Never use raw queries; use parameter binding
- **CSRF Protection**: All state-changing requests must be protected
- **Mass Assignment**: Always use $fillable or $guarded on Eloquent models

### 3. Testing Requirements
- **TDD Approach**: Write tests before or alongside implementation
- **Coverage Target**: Minimum {{ coverageTarget }}% code coverage
- **Test Types Required**: Unit, Feature, Architecture tests
- **No False Positives**: Tests must verify actual functionality, not just pass

---

## Coding Standards

### PHP Standards
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\PaymentGateway;
use App\DTOs\PaymentResult;
use App\Exceptions\PaymentFailedException;

/**
 * Payment processing service.
 *
 * Handles all payment-related operations with proper error handling
 * and logging for audit compliance.
 */
final readonly class PaymentService
{
    public function __construct(
        private PaymentGateway $gateway,
        private AuditLogger $logger,
    ) {}

    /**
     * Process a payment transaction.
     *
     * @param positive-int $userId
     * @param positive-int $amount Amount in cents
     *
     * @throws PaymentFailedException
     */
    public function process(int $userId, int $amount, string $currency = 'USD'): PaymentResult
    {
        // Implementation
    }
}
```

### Naming Conventions
| Type | Convention | Example |
|------|------------|---------|
| Classes | PascalCase | `UserRepository` |
| Methods | camelCase | `findByEmail()` |
| Variables | camelCase | `$userCount` |
| Constants | SCREAMING_SNAKE | `MAX_ATTEMPTS` |
| Database Tables | snake_case, plural | `user_profiles` |
| Database Columns | snake_case | `created_at` |

### File Organization
```
app/
├── Actions/           # Single-purpose action classes
├── Contracts/         # Interfaces (always here, not in Services/)
├── DTOs/              # Data Transfer Objects (readonly)
├── Enums/             # PHP 8.1+ enums
├── Events/            # Domain events
├── Exceptions/        # Custom exceptions
├── Http/
│   ├── Controllers/   # Thin controllers, max ~10 lines per method
│   ├── Middleware/    # Request/response middleware
│   ├── Requests/      # Form request validation
│   └── Resources/     # API resources
├── Jobs/              # Queue jobs
├── Listeners/         # Event listeners
├── Models/            # Eloquent models
├── Policies/          # Authorization policies
├── Repositories/      # Data access (if needed)
├── Services/          # Business logic services
└── Support/           # Helpers and utilities
```

---

## Architecture Guidelines

### Scale: {{ projectScale }}

{{#if isSimpleScale}}
#### Simple Architecture (Prototype/Small)
- Monolithic structure is acceptable
- Synchronous processing for most operations
- File-based caching sufficient
- Focus on shipping features quickly
{{/if}}

{{#if isBalancedScale}}
#### Balanced Architecture (Medium)
- Consider service classes for complex logic
- Use queues for non-critical async operations
- Redis for caching and sessions
- Database indexing becomes critical
{{/if}}

{{#if isScalableScale}}
#### Scalable Architecture (Large/Massive)
- Domain-driven design recommended
- Event-driven architecture for decoupling
- Horizontal scaling considerations
- Microservices may be appropriate
{{/if}}

### Patterns to Use
1. **Repository Pattern**: For complex data access logic
2. **Action Classes**: For single-purpose operations
3. **Service Classes**: For business logic coordination
4. **DTOs**: For data transfer between layers
5. **Events/Listeners**: For decoupled side effects

### Patterns to Avoid
1. **God Classes**: Classes doing too much
2. **Anemic Models**: Models with no behavior
3. **Service Locator**: Use dependency injection instead
4. **Static Methods**: Except for factory methods

---

## Database Guidelines

### Migration Best Practices
```php
// GOOD: Reversible migrations with proper types
Schema::create('orders', function (Blueprint $table) {
    $table->id();
    $table->foreignId('user_id')->constrained()->cascadeOnDelete();
    $table->unsignedInteger('total_cents');
    $table->string('currency', 3)->default('USD');
    $table->enum('status', ['pending', 'paid', 'shipped', 'delivered', 'cancelled']);
    $table->timestamps();
    $table->softDeletes();

    $table->index(['user_id', 'status']);
    $table->index('created_at');
});
```

### Query Optimization
- Always use `select()` to limit columns
- Use `chunk()` for large datasets
- Avoid N+1 with `with()` for relationships
- Add indexes for frequently queried columns
- Use `explain()` to analyze slow queries

---

## API Design

### Response Format
```json
{
    "success": true,
    "data": { },
    "message": "Operation successful",
    "meta": {
        "timestamp": "2024-01-01T00:00:00Z",
        "request_id": "uuid"
    }
}
```

### Error Response Format
```json
{
    "success": false,
    "error": {
        "code": "VALIDATION_ERROR",
        "message": "The given data was invalid.",
        "details": {
            "email": ["The email field is required."]
        }
    },
    "meta": {
        "timestamp": "2024-01-01T00:00:00Z",
        "request_id": "uuid"
    }
}
```

### HTTP Status Codes
| Code | Usage |
|------|-------|
| 200 | Success (GET, PUT, PATCH) |
| 201 | Created (POST) |
| 204 | No Content (DELETE) |
| 400 | Bad Request |
| 401 | Unauthorized |
| 403 | Forbidden |
| 404 | Not Found |
| 422 | Validation Error |
| 429 | Too Many Requests |
| 500 | Server Error |

---

## Testing Guidelines

### Test Structure (AAA Pattern)
```php
it('creates a new user with valid data', function () {
    // Arrange (Given)
    $data = [
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'password' => 'SecurePass123!',
    ];

    // Act (When)
    $response = post('/api/users', $data);

    // Assert (Then)
    $response->assertCreated();
    expect(User::where('email', $data['email'])->exists())->toBeTrue();
});
```

### What to Test
1. **Happy Path**: Normal successful operations
2. **Edge Cases**: Boundary conditions, empty inputs
3. **Error Cases**: Invalid inputs, missing data
4. **Authorization**: Permission checks
5. **Business Rules**: Domain logic validation

### What NOT to Do
- Don't test framework code
- Don't write tests that always pass
- Don't ignore failing tests
- Don't test implementation details

---

## Git Workflow

### Branch Naming
```
feature/ABC-123-add-user-authentication
bugfix/ABC-456-fix-login-redirect
hotfix/ABC-789-security-patch
refactor/ABC-012-extract-payment-service
```

### Commit Messages (Conventional Commits)
```
feat(auth): add two-factor authentication support

- Add TOTP-based 2FA implementation
- Add recovery codes generation
- Add 2FA middleware for protected routes

Closes #123

Co-Authored-By: Claude <noreply@anthropic.com>
```

### Types
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation
- `style`: Code style (no logic change)
- `refactor`: Code refactoring
- `perf`: Performance improvement
- `test`: Adding tests
- `build`: Build system changes
- `ci`: CI/CD changes
- `chore`: Maintenance tasks

---

## Security Checklist

Before committing, verify:
- [ ] No hardcoded credentials or secrets
- [ ] All user inputs are validated
- [ ] SQL queries use parameter binding
- [ ] Sensitive data is not logged
- [ ] CSRF protection is in place
- [ ] Authentication is required where needed
- [ ] Authorization checks exist for all resources
- [ ] Rate limiting is configured for public endpoints

---

## Performance Guidelines

### Do
- Use database indexes appropriately
- Implement caching for expensive operations
- Use eager loading for relationships
- Queue long-running tasks
- Optimize images and assets

### Don't
- Make database calls in loops
- Load entire tables into memory
- Ignore query performance
- Skip pagination for lists
- Store large files in database

---

## Package Selection Priority

1. **Laravel First-Party Packages** (e.g., Sanctum, Horizon, Scout)
2. **Spatie Packages** (e.g., laravel-permission, laravel-activitylog)
3. **Well-Maintained Community Packages** (>1000 stars, recent updates)
4. **Custom Implementation** (last resort)

### Evaluation Criteria
- Active maintenance (commits in last 6 months)
- Test coverage
- Documentation quality
- Community adoption
- Security track record

---

## Observability Requirements

### Logging
- Use structured logging (JSON format)
- Include request IDs for tracing
- Never log sensitive data
- Use appropriate log levels

### Metrics to Track
- Request latency (p50, p95, p99)
- Error rates by endpoint
- Queue job throughput
- Cache hit/miss ratios
- Database query times

---

## AI-Specific Instructions

### When Implementing Features
1. Read existing code first to understand patterns
2. Follow established conventions in the codebase
3. Write tests alongside implementation
4. Keep changes focused and minimal
5. Don't refactor unrelated code

### When Fixing Bugs
1. Write a failing test first
2. Make the minimal fix
3. Verify the test passes
4. Check for regression in related areas

### When Refactoring
1. Ensure tests exist and pass
2. Make small, incremental changes
3. Run tests after each change
4. Don't change behavior

### Forbidden Actions
- Never commit to main/master directly
- Never remove or bypass tests
- Never ignore static analysis errors
- Never hardcode environment values
- Never store secrets in code

---

*Generated by LaraForge - Version-Aware Development Orchestrator*
